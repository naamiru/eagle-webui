# Internationalization (next-intl)

Goal: introduce English (`en`) and Japanese (`ja`) support with next-intl while keeping the current URL structure (no locale prefixes). Persist the user’s language in the existing settings file that already stores global sort preferences.

## Step 1 – Framework Setup

1. **Locale config**
   - Create `i18n/config.ts` with:
     - `SUPPORTED_LOCALES = ["en", "ja"] as const`
     - `DEFAULT_LOCALE = "en"`
     - `type AppLocale = (typeof SUPPORTED_LOCALES)[number]`
     - `export function isAppLocale(locale: unknown): locale is AppLocale`
   - Export a `resolveLocale` helper that accepts `{ persisted?: string, requestLocale?: string }` (omit properties or set them to `undefined` when unknown) and returns a supported locale using the priority: persisted → request → default.

2. **Messages**
   - Add `i18n/messages/en.json` and `i18n/messages/ja.json`.
   - When messages are required (e.g., `i18n/request.ts`), load only the active locale with a dynamic import: `const messages = (await import(\`./messages/${locale}.json\`)).default;`. This keeps bundle size minimal and avoids loading unused locales.

3. **next-intl integration**
   - Update `next.config.ts` to wrap the exported config with `createNextIntlPlugin()`.
   - Create `i18n/request.ts`:
     ```ts
     import { getRequestConfig } from "next-intl/server";
     import { resolveLocale, type AppLocale } from "./config"; // from step 1
     import { loadLocaleSetting } from "@/data/settings"; // see Step 2

     export default getRequestConfig(async ({ requestLocale }) => {
       const persisted = await loadLocaleSetting();
       const locale = resolveLocale({ persisted, requestLocale });
       const messages = (await import(`./messages/${locale}.json`)).default;

       return {
         locale,
         messages,
       };
     });
     ```

4. **Root layout provider**
   - In `app/layout.tsx`, import `NextIntlClientProvider` from `next-intl`.
   - Render `<NextIntlClientProvider>…</NextIntlClientProvider>`. `getRequestConfig` already injected the locale and messages, so the client provider can infer them automatically.
   - Keep Mantine providers inside the intl provider so client components can access translations.

5. **Client utilities**
   - Create `i18n/client.ts` that re-exports `useTranslations`, `useLocale`, and `useMessages` from `next-intl` to keep imports consistent (`@/i18n/client`).

## Step 2 – Locale Preference & Settings UI

1. **Persisted settings**
   - Extract shared settings-file helpers into `data/settings.ts`:
     ```ts
     export type SettingsFile = {
       globalSort?: { …existing fields… };
       locale?: AppLocale;
     };
     ```
   - Export `loadSettings()`, `saveSettings(partial)`, `loadLocaleSetting()`, and `saveLocaleSetting(locale)`.
  - Use the shared helpers in `data/settings.ts` for both locale and global sort persistence so the file is only read once.

2. **Server action**
   - Add `actions/updateLocale.ts` that:
     - Validates input with `isAppLocale`.
     - Calls `saveLocaleSetting(locale)`.
     - Revalidates the shell (e.g., `revalidatePath("/")`) so the new locale applies immediately.
     - Returns a status object `{ ok: true }` or `{ ok: false, error: string }` for the client.

3. **Settings page**
   - Update `/settings`:
     - Read the current locale with `useLocale()` for the initial value.
     - On change, trigger the server action inside `startTransition`.
     - Disable the select or show a spinner while the update is pending.
     - Optionally show success/error notifications to confirm the change.

4. **Verification**
   - Add unit coverage for `resolveLocale` (accept persisted/request combinations, reject unsupported values).
   - Add an integration test (Vitest + Playwright or equivalent) that switches the language in `/settings` and confirms the value persisted in the settings file.

## Step 3 – Translations

1. **Message organization**
   - Use dot-notation keys grouped by feature (e.g., `navbar.settings`, `collection.filter.all`).
   - Keep keys identical across `en.json` and `ja.json`; treat missing keys as build failures.

2. **Usage patterns**
   - Server components: `const t = await getTranslations("namespace");`.
   - Client components: `const t = useTranslations("namespace");`.
   - Prefer next-intl’s formatting helpers for dates/numbers to keep locale rules centralized.

3. **Rollout**
   - After Steps 1 and 2 land, audit UI strings, move them into the message files, and replace hard-coded copy with translation lookups.
   - Add regression tests for any flows whose copy affects behavior (e.g., search filters).

The translation sweep (string extraction) is deferred; focus on the infrastructure and language selector first.
